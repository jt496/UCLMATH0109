import Mathlib

/-!
This project is on classifying groups of small order up to isomorphism.

There are two groups of order 4 (up to isomorphism):
  1. The cyclic group of order 4, `CyclicGroup 4`
  2. The Klein four-group, isomorphic to `CyclicGroup 2 × CyclicGroup 2`.

There are two groups of order 6 (up to isomorphism):
  1. The cyclic group of order 6, `CyclicGroup 6`
  2. The dihedral group of order 6, `DihedralGroup 3`.

There are five groups of order 8 (up to isomorphism):
  1. The cyclic group of order 8, `CyclicGroup 8`
  2. The direct product `CyclicGroup 4 × CyclicGroup 2`
  3. The direct product `CyclicGroup 2 × CyclicGroup 2 × CyclicGroup 2`
  4. The dihedral group of order 8, `DihedralGroup 4`
  5. The quaternion group of order 8, `QuaternionGroup 2`.

You might find the classification of finite abelian groups useful. This is in Mathlib:
-/
#check AddCommGroup.equiv_directSum_zmod_of_finite



namespace Group

/-
Note that `ZMod n` is the additive group of integers module `n`.
We make this into a multiplicative group with a generator `gen` as follows.
-/
notation3 "CyclicGroup " n => Multiplicative (ZMod n)
def gen : CyclicGroup n := Multiplicative.ofAdd 1




/--
If `G` is a group of order 4, it is either cyclic or isomorphic to the Klein four-group.
-/
theorem iso_of_order_four (G : Type) [Group G] (hG : Nat.card G = 4) :
    Nonempty (G ≃* CyclicGroup 4) ∨ Nonempty (G ≃* (CyclicGroup 2) × (CyclicGroup 2)) := by
  -- You might find it convenient to have a bijection `bij` between `G` and `Fin 4`,
  -- so that the group elements can be referred to as `bij 0`, `bij 1`, etc.
  -- the next three lines set this up for you.
  -- You can delete these lines if you don't use them.
  have : Nat.card G ≠ 0 := by norm_num [hG]
  have bij := (Nat.equivFinOfCardPos this).symm
  rw [hG] at bij
  /-
  Suppose `G` has an element `g` of order 4. Then `G` is generated by `g` and is cyclic,
  so `G ≃* CyclicGroup 4`.
  Otherwise, all non-identity elements of `G` have order 2. Let `a` and `b` be two distinct
  non-identity elements of `G`. Then `G = {e, a, b, ab}` and the map sending `a` to `(1,0)` and `b`
  to `(0,1)` extends to an isomorphism `G ≃* (CyclicGroup 2) × (CyclicGroup 2)`.
  -/
  sorry

/--
If `G` is a group of order 6, it is either cyclic or isomorphic to the dihedral group of order 6.
-/
theorem iso_of_order_six (G : Type) [Group G] [Finite G] (hG : Nat.card G = 6) :
    Nonempty (G ≃* CyclicGroup 6) ∨ Nonempty (G ≃* DihedralGroup 3) := by
  /-
  Suppose `G` has an element `g` of order 6. Then `G` is generated by `g` and is cyclic,
  so `G ≃* CyclicGroup 6`.
  Otherwise, by Cauchy's theorem, `G` has an element `a` of order 3 and an element `b` of order 2.
  The subgroup generated by `a` is normal in `G` since it has index 2.
  The conjugation action of `b` on `a` must send `a` to `a` or `a^{-1}`. It cannot send `a` to `a`
  since that would imply `b` commutes with `a` and thus `G` would be abelian and hence cyclic.
  Therefore, `b` conjugates `a` to `a^{-1}`. The map sending `a` to a rotation by 120 degrees
  and `b` to a reflection extends to an isomorphism `G ≃* DihedralGroup 3`.
  -/
  sorry

theorem iso_of_order_eight (G : Type) [Group G] [Finite G] (hG : Nat.card G = 8) :
    Nonempty (G ≃* CyclicGroup 8) ∨
    Nonempty (G ≃* (CyclicGroup 4) × (CyclicGroup 2)) ∨
    Nonempty (G ≃* (CyclicGroup 2) × (CyclicGroup 2) × (CyclicGroup 2)) ∨
    Nonempty (G ≃* DihedralGroup 4) ∨
    Nonempty (G ≃* QuaternionGroup 2) := by
  /-
  See the explanation in any textbook on group theory, or the explanation here:
  https://math.stackexchange.com/questions/64406/how-can-you-show-there-are-only-2-nonabelian-groups-of-order-8
  -/
  sorry


/-
If you'd like to do something more ambitions than this, you could try to prove the
classification theorem for groups of order `p³` for `p` a prime.
You can see a proof of this classification here:
https://math.stackexchange.com/questions/64406/how-can-you-show-there-are-only-2-nonabelian-groups-of-order-8
-/

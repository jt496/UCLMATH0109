import Mathlib.Tactic

/-!
Define the ring `D` whose elements have the form
`a+b*dx`, where `x` and `y` are real numbers, and `dx^2 = 0`.

Create a instances of `CommRing D` and `Module ℝ D` These say that `D` is a
commutative ring, and also a vector space over `ℝ`.

Show that `a+b*dx` is invertible iff `a ≠ 0`, and create an instance of `Inv D`.

Find out what an algebra is and create an instance of `Algebra ℝ D`.
Define an ordering on your ring so that `dx` is positive, but smaller than every
positive real number. Find out what an ordered ring is and create an
instance of this for `D`.

Prove that for any `f : ℝ[X]` and any `c : ℝ` we have $f(c + dx) = f(c) + f'(c) dx$.

Prove that the group of automorphisms of `D` (as an algebra over `ℝ`) is isomorphic to `ℝˣ`,
where a non-zero real number `c` corresponds to the automorphism `a + b * dx ↦ a + b * c * dx`.
-/

@[ext]
structure D where
  a : ℝ
  b : ℝ

instance : CommRing D where
  add r s := ⟨r.a + s.a, r.b + s.b⟩
  mul r s := ⟨r.a * s.a, r.a * s.b + s.a * r.b⟩
  neg r := ⟨-r.a, -r.b⟩
  zero := ⟨0,0⟩
  one := ⟨1,0⟩
  zero_add := sorry
  add_zero := sorry
  add_comm := sorry
  left_distrib := sorry
  zero_mul := sorry
  mul_zero := sorry
  mul_comm := sorry
  one_mul := sorry
  mul_one := sorry
  mul_assoc := sorry
  add_left_neg := sorry
  right_distrib := sorry
  add_assoc := sorry
  nsmul c r := ⟨c*r.a, c*r.b⟩
  nsmul_succ := sorry
  nsmul_zero := sorry
  zsmul c r := ⟨c*r.a, c*r.b⟩
  zsmul_neg' := sorry
  zsmul_succ' := sorry
  zsmul_zero' := sorry

/-
Define a coercion from `ℝ` ro `D`,
sending the real number `x` to `x + 0 * dx`.
-/
instance : Coe ℝ D where
  coe x := ⟨x,0⟩

def dx : D := ⟨0,1⟩

-- We can now write dual numbers in the usual way, for example:
#check 5 + 6 * dx

/-
Make some definitional lemmas for addition, multiplication etc. in `D`.
-/


namespace D


/-
Define the inverse of a dual number.
This should default to `0` if the dual number isn't invertible.
-/
noncomputable instance : Inv D where
  inv r := r.a⁻¹ - r.b * r.a⁻¹ ^ 2 * dx

lemma inv_mul_self (r : D) (h : r.a ≠ 0) : r⁻¹ * r = 1 :=
by
  sorry


lemma invertible_iff (r : D) : r.a ≠ 0 ↔ ∃ s : Dˣ, r = s :=
by
  sorry

/-
Define an ordering on the set of dual numbers.
You should do this in such a way that `a + b * dx ≤ a' + b' * dx` if and only
if `a < a'` or `a=a'` and `b ≤ b'`.
-/
def le (r s : D) : Prop := sorry

-- add a definitional lemma for `r ≤ s`

/-
Prove that the dual numbers form an "ordered ring".
-/
instance : OrderedRing D := sorry

/-
# Prove that `dx` is positive but smaller than every positive real number.
-/

/-
Here is a definition of what it means for a sequence of dual numbers to converge to a limit.
-/
def sLim (a : ℕ → D) (l : D) : Prop :=
  ∀ ε > 0, ∃ N, ∀ n, N ≤ n → (l - ε < a n ∧ a n < l + ε)




/-
# State and prove some standard theorems about limits.
For example:
* the limit of a sum is the sum of the limits.
* The limit of a product is the product of the limits.
* if `a` converges to `l` and `l` is invertible the `fun n ↦ (a n)⁻¹` converges to `l⁻¹`.
One the other hand, there are some difference:
* not every bounded increasing sequence converges to some limit. For example, prove that the following sequence
  is bounded and increasong but does not converge to any limit:

   `dx, 2*dx, 3*dx, ...`
-/






/-
Prove that the Dual numbers form a vector space over the real numbers.
-/
instance : Module ℝ D where
  smul r s := ↑r * s
  one_smul := sorry
  mul_smul := sorry
  smul_zero := sorry
  zero_smul := sorry
  add_smul := sorry
  smul_add := sorry

-- make a definitional lemma for `r • s`.


/-
Show that the dual numbers form an algebra over `ℝ`.
(an algebra over `ℝ` is both a ring and a vector space, with a few other axioms.)
-/
instance : Algebra ℝ D := sorry



open Polynomial

/-
prove that `f(x + dx) = f(x) + f'(x) * dx`, where `f` is a polynomial and `x` is a real number.
-/
theorem aeval (f : ℝ[X]) (x : ℝ) :
    aeval ( x + dx ) f = aeval x f + (aeval x (derivative f)) * dx :=
by
  sorry

/-
Prove that every ideal of the ring `D` is either the zero ideal or the whole ring or the
principal ideal generated by `dx`.
-/
theorem ideal_eq (I : Ideal D) : I = ⊥ ∨ I = ⊤ ∨ I = Ideal.span {dx} := by
  sorry

/-
Given a non-zero real number `c`, construct an algebra automorphism `σ c`
of `D` which takes `x + y * dx` to `x + c * y * dx`.
-/
def σ (c : ℝˣ) : D ≃ₐ[ℝ] D := sorry

/-
 # Prove that the automorphism `σ c` is monotone (i.e. increasing) if and only if `c > 0`.
-/

/-
Prove that the map `c ↦ σ c` is an automorphism between the
group of non-zero real numbers and the group of algebra automorphisms of `D`.
-/
def AutD_equiv : ℝˣ ≃* (D ≃ₐ[ℝ] D) := sorry


/-
 # Prove that if `F` is a field and `φ : D →+* F` is a ring homomorphism then `φ dx = 0`.
 # In fact, prove that the kernel if `φ` is the prinicpal ideal generated by `dx`.
-/


/-
Hence give a bijection between `D →+* F` and `ℝ →+* F`.

Given, `φ : D →+* F`, the corresponding `ψ : ℝ →+* F` is just the restriction of `φ` to `ℝ`.
On the other hand, given `ψ : ℝ → F`, we can construct `φ : D → F` by `φ (x + y * dx) = ψ x`.
-/
def D_to_field_equiv [Field F] : (D →+* F) ≃ (ℝ →+* F) := sorry
